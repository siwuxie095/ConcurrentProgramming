package com.siwuxie095.concurrent.chapter7th.example4th;

/**
 * @author Jiajing Li
 * @date 2020-10-02 16:42:46
 */
public class Main {

    /**
     * 关于消息投递的一些说明
     *
     * 整个 Akka 应用是由消息驱动的。消息是除了 Actor 之外最重要的核心组件。作为在并发程序中的核心组件，在 Actor 之间
     * 传递的消息应该满足不可变性，也就是不变模式。因为可变的消息无法高效的在并发环境中使用。理论上 Akka 中的消息可以使
     * 用任何对象实例，但实际使用中，强烈推荐使用不可变的对象。
     *
     * 以 ImmutableMessage 为例，就是一个典型的不可变对象的实现。它实现了一个不可变的消息。注意代码中对 final 的使用，
     * 它声明了当前消息中的两个字段都是常量，在消息构造完成后，就不能再发生改变了。更加需要注意的是，对于 values 字段，
     * final 关键字只能保证 values 引用的不可变性，并无法保证 values 中的对象的不可变性。为了实现彻底的不可变性，直接
     * 构造了一个不可变的 List 对象。
     *
     * 对于消息投递，可能还有另外一个疑问，那就是消息投递究竟是以何种策略进行的呢？也就是发出去的消息一定会被对方接收到吗？
     * 如果接收不到会重发吗？有没有可能重复接收消息呢？
     *
     * 实际上，对于消息投递，可以有三种不同的策略：
     *
     * （1）第一种，称为至多一次投递。在这种策略中，每一条消息最多会被投递一次。在这种情况下，可能偶尔会出现消息投递失败，
     * 而导致消息丢失。
     *
     * （2）第二种，称为至少一次投递。在这种策略中，每一条消息至少会被投递一次，直到成功为止。因此，在一些偶然的场合，接
     * 收者可能会收到重复的消息，但不会发生消息丢失。
     *
     * （3）第三种，称为精确的消息投递。也就是所有的消息保证被精确地投递并成功接收一次，既不会有丢失，也不会有重复接收。
     *
     * 显然，第一种策略是最高性能、最低成本的。因为系统只要负责把消息送出去就可以了，不需要关注是否成功。第二种策略则需要
     * 保存消息投递状态并不断重试。而第三种策略则是成本最高且最不容易实现的。
     *
     * 那是否真的需要保证消息投递的可靠性呢？
     *
     * 答案是否定的。实际上，并没有必要在 Akka 层保证消息的可靠性。这样做，成本太高了，也是没有必要的。消息的可靠性更应
     * 该在应用的业务层去维护，因为也许在有些时候，丢失一些消息完全是符合应用要求的。因此，在使用 Akka 时，需要在业务层
     * 对此进行保证。
     *
     * 此外，对于消息投递，Akka 可以在一定程度上保证顺序性。比如，Actor A1 向 A2 顺序发送了 M1、M2、M3 三条消息。
     * Actor A3 向 A2 顺序发送了 M4、M5、M6 三条消息。那么系统可以保证：
     * （1）如果 M1 没有丢失，那它一定先于 M2 和 M3 被 A2 收到。
     * （2）如果 M2 没有丢失，那它一定先于 M3 被 A2 收到。
     * （3）如果 M4 没有丢失，那它一定先于 M5 和 M6 被 A2 收到。
     * （4）如果 M4 没有丢失，那它一定先于 M6 被 A2 收到。
     * （5）对 A2 来说，来自 A1 和 A3 的消息可能交织在一起，没有顺序保证。
     *
     * 值得注意的是，这种消息投递规则不具备可传递性。比如：有三个 Actor，分别是 A、B、C。A 向  B 发送了 M1，接着 A 向
     * B 发送了 M2，B 将 M2 转发给 C。那么在这种情况下，C 收到 M1 和 M2 的先后顺序是没有保证的。
     */
    public static void main(String[] args) {

    }

}
