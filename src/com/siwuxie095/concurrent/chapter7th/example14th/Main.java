package com.siwuxie095.concurrent.chapter7th.example14th;

/**
 * @author Jiajing Li
 * @date 2020-10-04 11:01:39
 */
public class Main {

    /**
     * 并发粒子群的实现
     *
     * 粒子群算法（PSO）是一种进化算法。它与大名鼎鼎的遗传算法非常类似，可以用来解决一些优化问题。众所周知，一些优化问题
     * （比如旅行商问题 TSP）都属于 NP 问题。它们的时间复杂度可能会达到 O(n!) 或者 O(2^n)，这种在多项式时间内不可解的
     * 问题总是会让人望而生畏。而以 PSO 算法为代表的进化计算，往往可以将这些 NP 问题，转变为一个多项式问题。但这种转变是
     * 有代价的，进化算法往往都不保证可以从结果中得到最优解。这么说，可能有人会有疑问，这个算法都不能保证得到最优解，那有
     * 什么用呢？其实，在生活中的很多场景下，并不是特别需要最优解，更加希望的是一个满意解。比如，去水果店买西瓜，店里可能
     * 放着一大堆西瓜，每个人都想挑一个最好的。但你想拿到最好的那个西瓜必须得挨个检查过去，并且还得认真做好记录才行。但是
     * 没有人会这么买西瓜，因为成本太高了。对于大部分人来说，更倾向于在表面上挑几个顺眼的看看，如果还过得去，也就下手了。
     * 这也就是说只要这个结果不要差得太离谱就行了。
     *
     * 既然最优的方案很难得到，那么就想办法以很低的成本获得一个还算过得去的方案，也不失为一计良策。在很多情况下，虽然进化
     * 算法无法获得最优解，也无法证明它得到的解与最优解到底有多少差距，但在实际中，通过进化算法搜索到的满意解很可能与最优
     * 解已经非常接近了。
     *
     * PS：
     * （1）PSO 即 Particle Swarm Optimization，粒子群优化，又称微粒群算法。
     * （2）TSP 即 Travelling Salesman Problem，旅行商问题，又称旅行推销员问题，是一个最短路径问题。
     * （3）NP 即 Non-deterministic Polynomial，非决定性多项式集合，又称非确定性多项式集合，NP 包含 P 和 NPC。
     *
     *
     *
     * 什么是粒子群算法
     *
     * 粒子群优化算法（PSO）是一种进化计算技术，最早由 Kennedy 与 Eberhart 于 1995 年提出。它源于对鸟群捕食行为的研究，
     * 与遗传算法相似，一种基于迭代的优化算法，广泛应用于函数优化和神经网络训练等方面。与遗传算法相比，PSO 算法的实现简单
     * 得多，参数配置也相对较少，对使用人员的经验要求不高，因此更加易于实际工程应用。
     *
     * 从日常生活的观察中可以知道，鸟类的觅食往往会表现出群体特性。如果在地上有一小撮食物，那么鸟群很可能就会聚集在这一堆食
     * 物旁边。如果其中一只小鸟发现了另外一堆更丰盛的食物，那它可能会离群飞向更丰盛的食物，而这有可能带动整个鸟群一起飞向新
     * 的地点。当然了，在整个种群中，难免会出现几只特别有个性的小鸟，它们不喜欢太热闹的地方，当整个种群迁移时，它们不会跟着
     * 种群走，或是自己散步，或是自行游荡。
     *
     * 粒子群算法正是对上述过程的模拟。在程序中，可以模拟大量的小鸟，小鸟的觅食点正是要求解的问题的解。解越是优秀，意味着食
     * 物越是丰盛，因此，模拟的小鸟会从自己的位置出发，以一定的速度向最优点的方向移动。在移动过程中，任何一只小鸟都有可能发
     * 现更好的解，这又会进一步影响群体的行为。就这样如此反复迭代，最终将得到一个不错的答案。
     *
     *
     *
     * 粒子群算法的计算过程
     *
     * 粒子群算法的大体步骤如下：
     * （1）初始化所有粒子，粒子的位置随机生成。计算每个粒子当前的适应度，并将此设为当前粒子的个体最优值（记为 pBest）。
     * （2）所有粒子都将自己的个体最优值发送给管理者 Master。Master 获得所有粒子的信息后，筛选出全局最优的解（记为
     * gBest）。
     * （3）Master 将 gBest 通知所有粒子，所有粒子便知道全局最优点的位置。
     * （4）接着，所有粒子根据自己的 pBest 和全局 gBest，更新自己的速度，在有了速度之后，再更新自己的位置。
     * （5）如果粒子产生了新的个体最优值，则发送给 Master。然后转到步骤（2）。
     *
     * 从这个计算步骤可以看到，计算过程拥有一定的随机性。但由于可以启用大量的粒子，因此其计算效果在统计学意义上是稳定的。在
     * 这个标准的粒子群算法中，由于所有粒子都会向全局最优靠拢，因此，其跳出局部最优的能力并不算太强。但是可以想办法对标准的
     * 粒子群算法进行一些合理的改进。比如，允许各个粒子随机移动，甚至逆向移动来试图突破局部最优。
     *
     *
     *
     * 粒子群算法能做什么
     *
     * 粒子群算法能做些什么呢？它应用最多的场景是进行最优化计算。实际上，以粒子群算法为代表的进化计算，可以说是最优化方法中
     * 的通用方法。几乎一切最优化问题都可以通过这种随机搜索的模式解决，其成本低、难度小、效果好。因此颇受欢迎。
     *
     * 下面看一个典型的优化问题：
     *
     * 假设现在有 400 万资金，要求四年内使用完。若在第一年使用 x 万元，则可以得到效益 √x 万元（效益不能再使用），当年不用
     * 的资金可存入银行，年利率为 10%。尝试制订出资金的使用规划，使四年效益之和最大。
     *
     * 很明显，对于这类问题，不同的方案得到的结果可能会有很大的差异。比如，如果第一年把 400 万元全部用完，则总效益为 √400
     * = 20 万元；如果前三年均不用而存入银行，第四年把本金和利息全部用完，则总效益为 √(400 * 1.1^3) = 23.7 万元，显然
     * 优于第一种方案。
     *
     * 如果将此问题转化为一般化的优化问题（一般化的约束问题），则可以得到以下方程组。
     *
     * max = √x1 + √x2 + √x3 + √x4
     *
     * s.t.
     *
     * x1 <= 400
     * 1.1*x1 + x2 <= 440
     * 1.21*x1 + 1.1*x2 + x3 <= 484
     * 1.331*x1 + 1.21*x2 + 1.1*x3 + x4 <= 532.4
     * x1, x2, x3, x4 >= 0
     *
     * PS：s.t. 即 subject to，使得 ... 满足 ...
     *
     * 其中 x1、x2、x3、x4 分别表示第一、二、三、四年使用的资金。使用拉格朗日乘子法对此方程组进行求解，可以得到第一年使用
     * 86.19 万元、第二年使用 104.29 万元、第三年使用 126.19 万元、第四年使用 152.69 万元是这个问题的最优解，此时总效
     * 益达 43.09 万元。
     *
     * 由于求解过程过于复杂，使用拉格朗日乘子法时，需要对先后 12 个未知数和方程进行联立求解，比较难以实现。求解过程，这里
     * 不再罗列。
     *
     * 对于类似的优化问题，正是粒子群算法的涉猎范围。当使用粒子群算法时，可以先随机给出若干个满足提交的资金规划方案。接着，
     * 根据粒子群的演化公式，不断调整每个粒子的位置（粒子的每一个位置代表一套方案），逐步探索更优的方案。
     *
     *
     *
     * 使用 Akka 实现粒子群
     *
     * 现在已经知道粒子群的原理，并且有了一个较为复杂的优化问题等待求解。接下来就需要开动脑筋，使用 Akka 来实现一个简单的
     * 粒子群，来解决这个优化问题。
     *
     * 使用 Actor 的模式与粒子群算法之间有着天生切合度。粒子群算法由于涉及到多个甚至是极其大量的粒子参与运算，因此它隐含并
     * 行计算的模式。其次，从直观上也可以知道，粒子群算法的求解精度或者说求解质量，与参与运算的粒子有着直接的关系。显然，参
     * 与运算的粒子数量越多，得到的解自然也就越精确。
     *
     * 如果使用传统的多线程方式实现粒子群，一个最大的问题就是线程的数量可能是非常有限的。在当前这种应用场景中，希望可以拥有
     * 数万，甚至数十万的粒子，以提高计算精度，但众所周知，在一台计算机上运行数万个线程基本是不可能但，就算可以，系统的性能
     * 也会大打折扣。因此，使用多线程模型无法很好地和粒子群的实现相融合。
     *
     * 但 Akka 的 Actor 模型则不同。由于多个 Actor 可以复用一个线程，而 Actor 本身作为轻量级的并发执行单元可以有极其大
     * 量的存在。因此就可以使用 Actor 来模拟整个粒子群计算的场景。
     *
     * 以 PsoValue、PBestMsg、GBestMsg、Particle、Master 等类为例，展示系统的实现。
     *
     * 其中 PBestMsg 和 GBestMsg 分别表示 pBest 和 gBest 的消息类型，用于在多个 Actor 之间传递个体最优和全局最优。
     * （1）PBestMsg 携带个体最优解的消息；
     * （2）GBestMsg 携带全局最优解的消息；
     * 它们都使用 PsoValue 来表示一个可行的解。
     *
     * 在 PsoValue 中，主要包含两个信息：
     * （1）List<Double> x：表示投资规划的方案，即每一年分别需要投资多少钱；
     * （2）double value：表示这个投资方案的总收益；
     *
     * 在列表 x 中，x[1]、x[2]、x[3]、x[4] 分别表示第一年、第二年、第三年和第四年的投资额。这里为了方便起见，直接忽略了
     * x[0]（它在程序中是没有作用的）。
     *
     * 根据需求，就可以在 Fitness 中体现 x 和 value 之间的关系。其中的 fitness() 方法返回了给定投资方案的适应度。这里
     * 适应度也就是投资的总收益，那么自然应该倾向于选择适应度更高投资方案。此处，适应度 = √x1 + √x2 + √x3 + √x4。
     *
     * 有了这些基础工具后，就可以实现简单的粒子了，这里叫做 Particle。
     *
     * 其中 pBest 和 gBest 分别表示个体最优和全局最优，velocity 表示粒子在各个维度上的速度（在当前案例中，每一年的投资
     * 额就可以认为是一个维度，因此系统就有四个维度）。x 表示投资方案，即每一年的投资额。由于在粒子群算法中，需要使用随机
     * 数，所以这里还定义了 r。
     *
     * 当一个粒子被创建时，需要初始化粒子的当前位置。粒子的每一个位置都代表一个投资方案。在 preStart() 方法中是粒子的初始
     * 化逻辑。由于每一年的投资额度是有条件约束的，比如第一年的投资额不能超过 400 万，而第二年的投资上限是 440 万（假设第
     * 一年全部存银行），以此类推。粒子初始化时，随机生成一组满足基本约束条件的投资组合，并计算它的适应度。初始的投资方案自
     * 然也就作为当前的个体最优，并发送给 Master。
     *
     * 当 Master 计算出当前全局最优后，会将全局最优发送给每一个粒子，粒子根据全局最优更新自己的运行速度，并更新自己的速度
     * 以及当前位置。
     *
     * 在消息处理方法 onReceive() 中，粒子接收到了全局最优，接着根据粒子群的标准公式更新自己的速度，接着根据速度更新自己
     * 的位置。由于当前问题是有约束的，也就是说解空间并不是随意的。粒子很可能在更新位置后，跑出了合理的范围之外，因此，还有
     * 必要进行有效性检查。
     *
     * 在更新完成后，就可以计算新位置的适应度，如果产生了新的个体最优，就将其发送给 Master。
     *
     * Master 主要用于管理和通知全局最优。
     *
     * 在消息处理方法 onReceive() 中，当收到一个个体最优的解时，会将其与全局最优进行比较，如果产生了新的全局最优，就更新
     * 这个全局最优并通知所有粒子。
     *
     * 在 ActorBot 中，定义了粒子总数，为 10 万，接着在主方法中创建了一个 Master 和 10 万个 Particle。
     *
     * 运行代码，结果如下：
     *
     * value: 34.94643053589823
     * x: [-Infinity, 312.0, 24.714598481477722, 60.65950171401142, 20.458522939425855]
     *
     * value: 40.165984407019664
     * x: [-Infinity, 72.0, 70.58239585252264, 249.55209068929693, 55.98260210141396]
     *
     * value: 41.69969270596145
     * x: [-Infinity, 69.0, 92.56363628126405, 159.49442521599792, 124.1655321043966]
     *
     * value: 42.00909126922434
     * x: [-Infinity, 76.0, 86.07115715797724, 184.7687796076539, 108.59455495233337]
     *
     * value: 42.19154600969694
     * x: [-Infinity, 126.0, 97.4304157105462, 86.429564297789, 139.21968080572069]
     *
     * value: 42.2713592699464
     * x: [-Infinity, 50.0, 168.1557766136171, 101.76305571742228, 147.50186573255436]
     *
     * value: 42.63619084732518
     * x: [-Infinity, 80.0, 155.6751157027895, 116.09550956239073, 108.99720971438447]
     *
     * value: 42.71380451355763
     * x: [-Infinity, 65.0, 129.04829985151204, 111.03430807819308, 162.67273411437665]
     *
     * value: 42.97620334375714
     * x: [-Infinity, 78.0, 130.392972494023, 121.26943972483589, 137.19970540913482]
     *
     * value: 43.024755442259575
     * x: [-Infinity, 83.0, 100.05843382145619, 115.28933704874873, 173.55726306541365]
     *
     * value: 43.0667568606679
     * x: [-Infinity, 81.0, 103.84011875455681, 130.90197998712085, 154.63716745246833]
     *
     * 可以看到，当粒子群随机初始化时，最优解为 34.95 万元，但随着粒子的搜索，这个投资方案被逐步优化，一直上升到 43.07 万
     * 元。根据前面的求解，已知这个投资方案的最优结果是 43.09 万元。显然，粒子群的搜索结果和全局最优已经非常接近了。
     *
     * 当然，由于粒子群算法的随机性，每次执行结果可能并不一样，这意味着有时候，可能会求得更好的解，或者得到一个稍差一些解，
     * 但其偏差不会相差太远。
     */
    public static void main(String[] args) {

    }

}
