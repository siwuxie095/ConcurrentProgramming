package com.siwuxie095.concurrent.chapter4th.example16th;

/**
 * @author Jiajing Li
 * @date 2020-09-13 18:21:33
 */
public class Main {

    /**
     * 与众不同的并发策略：比较并交换(CAS)
     *
     * 与锁相比，使用比较并交换（下文简称 CAS）会使程序看起来更加复杂一些。但是由于其非阻塞性，它对死锁问题
     * 天生免疫（因为无锁），并且线程线程间的相互影响也远远比基于锁的方式要小。更为重要的是，使用无锁的方式
     * 完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，所以比基于锁的方式拥有更优越的性能。
     *
     * PS：比较并交换，有时也称 比较并替换。
     *
     * CAS 算法的过程是这样：它包含三个参数 CAS(V, E, N)。V 表示要更新的变量，E 表示预期值，N 表示新值。
     * 仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则
     * 当前线程什么都不做。最后 CAS 返回当前 V 的真实值。CAS 操作是抱着乐观的态度进行的，它总是认为自己可
     * 以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失
     * 败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，
     * CAS 即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。
     *
     * 简单地说，CAS 需要你额外给出一个期望值，也就是主观上所认为这个变量现在应该是什么样子的。如果变量不是
     * 所想象的那样，那说明它已经被别人修改过了。就需要重新读取它，再次尝试修改就好了。
     *
     * 在硬件层面，大部分的现代处理器都已经支持原子化的 CAS 指令。在 JDK 5 之后，虚拟机便可以使用这个指令
     * 来实现并发操作和并发数据结构，并且这种操作在虚拟机中可以说是无处不在。
     *
     * PS：CAS 往往也被称为乐观锁，实际上是无锁。而如果真的有锁，相对于乐观锁而言，则被称为悲观锁。乐观锁的
     * 的实现一般有两种方式：（1）版本号机制；（2）CAS 算法。
     */
    public static void main(String[] args) {

    }

}
