package com.siwuxie095.concurrent.chapter4th.example11th;

/**
 * @author Jiajing Li
 * @date 2020-09-12 22:14:19
 */
public class Main {

    /**
     * JVM 对锁优化所做的努力：锁粗化
     *
     * 原则上，在编写代码时，总是推荐将同步块的作用范围限制的尽量小 -- 只在共享数据的实际作用域中才进行同步，这样
     * 是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。
     *
     * 大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都是对同一个对象反复加锁和解锁，甚至加锁操作是
     * 出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。
     *
     * 场景举例：在循环体中加锁，或者是使用 StringBuffer 进行连续 append() 操作。
     *
     * 如果 JVM 探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁的同步范围扩展（粗化）到整个操作序列的外部。
     */
    public static void main(String[] args) {

    }

}
