package com.siwuxie095.concurrent.chapter4th.example19th;

/**
 * @author Jiajing Li
 * @date 2020-09-14 07:19:29
 */
public class Main {

    /**
     * 无锁的对象引用：AtomicReference
     *
     * AtomicReference 和 AtomicInteger 非常类似，不同之处就在于 AtomicInteger 是对整数的封装，而
     * AtomicReference 则对应普通的对象引用。也就是它可以保证你在修改对象引用时的线程安全性。
     *
     * 在介绍 AtomicReference 之前，这里先提出一个有关原子操作在逻辑上的不足。已知线程判断被修改对象是
     * 否可以正确写入的条件是对象的当前值和期望值是否一致。这个逻辑从一般意义上来说是正确的。但有可能出现
     * 一个小小的例外，就是在获得对象的当前值之后，准备修改为新值之前，对象的值被其他线程连续修改了两次，
     * 而经过这两次修改后，对象的值又恢复为原来的值。这样，当前线程就无法正确判断这个对象是否被修改过。
     *
     * （即 对象的值被反复修改，又回到原值）
     *
     * 一般来说，发生这种情况的概率很小。而且即使发生了，可能也不是什么大问题。比如，只是简单地要做一个数
     * 值加法，即使在取得期望值后，这个数字被不断修改，只要它最终改回到了期望值，那么加法计算就不会出错。
     * 也就是说，修改的对象没有过程的状态信息，所有的信息都只保存于对象的数值本身。
     *
     * 但是，在现实中还可能存在另外一种场景，就是是否能修改对象的值，不仅取决于当前值，还和对象的过程变化
     * 有关，这时，AtomicReference 就无能为力了。
     *
     * 打个比方，如果有一家蛋糕店，为了挽留客户，决定为贵宾卡里余额小于 20 元的客户一次性赠送 20 元，刺激
     * 消费者充值和消费。但条件是，每一位客人只能被赠送一次。
     *
     * 以 AtomicReferenceDemo 为例，来模拟这个场景。首先定义了用户账户余额为 19 元，然后开启了 3 个后
     * 台线程，不断扫描数据，为满足条件的客户充值。其中会判断用户余额并给予赠送金额。如果已经被其他线程处理，
     * 那么当前线程就会失败。因此，可以确保用户只会被充值一次。
     *
     * 此时，如果很不幸，用户正好在进行消费，就在赠予金额到账的同时，用户进行了一次消费，使得总金额又小于
     * 20 元，并且正好累计消费了 20 元，使得赠予后、消费后的金额等于赠予前、消费前的金额（即 前后金额又相
     * 等了）。这时，后台的赠予线程就会误以为这个账户还没有赠予，所以存在被多次赠予的可能。
     *
     * 运行代码，输出如下：
     *
     * 余额大于 20 元，无须充值
     * 余额小于 20 元，充值成功，余额：39 元
     * 余额大于 20 元，无须充值
     * 大于 10 元
     * 成功消费 10 元，余额：29 元
     * 余额大于 20 元，无须充值
     * 余额大于 20 元，无须充值
     * 大于 10 元
     * 余额大于 20 元，无须充值
     * 成功消费 10 元，余额：19 元
     * 余额大于 20 元，无须充值
     * 余额大于 20 元，无须充值
     * 余额小于 20 元，充值成功，余额：39 元
     * 大于 10 元
     * 成功消费 10 元，余额：29 元
     *
     * ...
     *
     * 从输出可以看出这个账户被先后反复多次充值。其原因正是因为账户余额被反复修改，修改后的值等于原有的数值，
     * 使得 CAS 操作无法正确判断当前数据状态。
     *
     * 虽然说这种情况出现的概率不大，但是依然是有可能出现的。因此，当业务上确实可能出现这种情况时，必须多加
     * 防范。体贴的 JDK 也已经考虑到了这种情况，使用 AtomicStampedReference 就可以很好地解决这个问题。
     */
    public static void main(String[] args) {

    }

}
