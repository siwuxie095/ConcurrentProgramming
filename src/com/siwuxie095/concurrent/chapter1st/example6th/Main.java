package com.siwuxie095.concurrent.chapter1st.example6th;

/**
 * @author Jiajing Li
 * @date 2020-08-19 23:20:28
 */
public class Main {

    /**
     * 可见性（Visibility）
     *
     * 可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。显然，
     * 对于串行程序来说，可见性问题是不存在的。因为你在任何一个操作步骤中修改了某个变量，那
     * 么在后续的步骤中，读取这个变量的值，一定是修改后的新值。
     *
     * 但是这个问题在并行程序中就不见得了。如果一个线程修改了某一个全局变量，那么其他线程未
     * 必可以马上知道这个改动。例如，在 CPU1 和 CPU2 上各运行了一个线程，它们共享变量 t，
     * 由于编译器优化或者硬件优化的缘故，在 CPU1 上的线程将变量 t 进行了优化，将其缓存在
     * cache 或者寄存器里。这种情况下，如果在 CPU2 上的某个线程修改了变量 t 的实际值，那
     * 么 CPU1 上的线程可能就无法意识到这个改动，依然会读取 cache 中或者寄存器里的数据。
     * 因此，就产生了可见性问题。外在表现为：变量 t 的值被修改，但是 CPU1 上的线程依然会读
     * 到一个旧值。可见性问题也是并行程序开发中需要重点关注的问题之一。
     *
     * 可见性问题是一个综合性问题。除了上述提到的缓存优化或者硬件优化（有些内存读写可能不会
     * 立即触发，而会先进入一个硬件队列等待）会导致可见性问题外，指令重排以及编译器的优化，
     * 都可能导致一个线程的修改不会立即被其他线程察觉。
     *
     * 看一个简单的例子：
     * Thread 1         Thread 2
     * 1: r2 = A;        3: r1 = B;
     * 2: B = 1;         4: A = 2;
     *
     * 上述两个线程并行执行，分别有 1、2、3、4 四条指令，其中指令 1、2 属于线程 1，指令
     * 3、4 属于线程 2。
     *
     * 从指令的执行顺序上看，r2 = 2 且 r1 = 1 似乎是不可能出现的。但实际上，并没有办法从
     * 理论上保证这种情况不出现。因为编译器可能将指令重排成：
     *
     * Thread 1         Thread 2
     * B = 1;           r1 = B;
     * r2 = A;          A = 2;
     *
     * 在这种执行顺序中，就有可能出现刚才看似不可能出现的 r2 = 2 且 r1 = 1 的情况了。这
     * 个例子就说明了，在一个线程中去观察另一个线程的变量，它们的值是否能观测到、何时能观测
     * 到是没有保证的。
     *
     * 再看一个稍微复杂一些的例子：
     * Thread 1         Thread 2
     * r1 = p;          r6 = p;
     * r2 = r1.x;       r6.x = 3;
     * r3 = q;
     * r4 = r3.x;
     * r5 = r1.x;
     *
     * 这里假设初始时，p == q 且 p.x = 0。对于大部分编译器来说，可能会对线程 1 进行向前替换
     * 的优化，也就是 r5 = r1.x 这条指令会被直接替换成 r5 = r2。因为它们都读取了 r1.x，又发
     * 生在同一个线程中，因此，编译器很可能认为第 2 次读取是完全没有必要的。所以，上述指令可能
     * 会变成：
     *
     * Thread 1        Thread 2
     * r1 = p;          r6 = p;
     * r2 = r1.x;       r6.x = 3;
     * r3 = q;
     * r4 = r3.x;
     * r5 = r2;
     *
     * 现在思考这么一种场景，假设线程 2 中的 r6.x = 3 发生在 r2 = r1.x 和 r4 = r3.x 之间，
     * 而编译器又打算重用 r2 来表示 r5。那么就有可能出现非常奇怪的现象。你看到的 r2 是 0，r4
     * 是 3，但是 r5 还是 0。因此，如果从线程 1 代码的直观感觉上看就是：p.x 的值从 0 变成了
     * 3（因为 r4 是 3），接着又变成了 0（这算是一个非常怪异的问题）。
     */
    public static void main(String[] args) {

    }

}
