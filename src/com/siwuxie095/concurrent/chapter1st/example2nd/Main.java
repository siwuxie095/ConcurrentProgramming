package com.siwuxie095.concurrent.chapter1st.example2nd;

/**
 * @author Jiajing Li
 * @date 2020-01-07 23:18:54
 */
public class Main {

    /**
     * 并发级别：
     * 由于临界区的存在，多线程之间的并发必须受到控制。根据控制并发的策略，可以把并发的级别
     * 进行分类，大致可以分为五种：阻塞、无饥饿、无障碍、无锁、无等待。
     *
     * （1）阻塞（Blocking）
     *  一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。当使用 synchronized
     *  关键字，或者 ReentrantLock 重入锁时，得到的就是阻塞的线程。
     *
     *  无论是 synchronized 或者 ReentrantLock，都会试图在执行后续代码前，得到临界区的
     *  锁，如果得不到，线程就会被挂起等待，直到占有了所需资源为止。
     *
     *  总结：当出现 synchronized 关键字或 ReentrantLock 重入锁，并发级别就为阻塞。
     *
     *
     * （2）无饥饿（Starvation-Free）
     * 如果线程之间是有优先级的，那么线程调度的时候总是会倾向于满足高优先级的线程。也就是说
     * ，对于同一个资源的分配是不公平的。
     *
     * 对于非公平的锁来说，系统允许高优先级的线程插队。这样有可能导致低优先级线程产生饥饿。
     * 但如果锁是公平的，满足先来后到，那么饥饿就不会产生，不管新来的线程优先级多高，要想
     * 获得资源，就必须乖乖排队。那么所有线程都有机会执行。
     *
     * 总结：当出现公平锁，并发级别就是无饥饿。
     */
    public static void main(String[] args) {

    }

}
