package com.siwuxie095.concurrent.chapter1st.example1st;

/**
 * @author Jiajing Li
 * @date 2020-01-07 23:18:54
 */
public class Main {

    /**
     * 几个概念：
     *
     * （1） 同步（Synchronous）和异步（Asynchronous）
     * 同步和异步通常用来形容一次方法调用。同步方法调用一旦开始，调用者必须等到方法调用返回后，
     * 才能继续后续的行为。异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用
     * 者就可以继续后续的操作。而异步方法通常会在另一个线程中 "真实" 地执行。整个过程不会阻碍
     * 调用者的工作。如果异步方法调用需要返回返回结果，那么当这个异步方法调用真实完成时，就会
     * 通知调用者。
     *
     * PS：
     * 同步方法调用，也称为 同步调用
     * 异步方法调用，也称为 异步调用
     * 同步方法，即 被调用的同步方法
     * 异步方法，即 被调用的异步方法
     *
     *
     * （2）并发（Concurrency）和并行（Parallelism）
     *并发和并行是两个非常容易被混淆的概念。它们都可以表示两个或者多个任务一起执行，但是偏重点
     * 有些不同。并发偏重于多个任务交替执行，而多个任务之间有可能还是串行的。而并行是真正意义
     * 上的 "同时执行"。
     *
     * 严格意义上来说，并行的多个任务是真实的同时执行，而对于并发来说，这个过程只是交替的，一
     * 会儿运行任务 A 一会儿执行任务 B，系统会不停地在两者见切换。但对于外部观察者来说，即使
     * 多个任务之间是串行并发的，也会造成多任务间是并行执行的错觉。
     *
     * 实际上，如果系统内只有一个 CPU，这时使用多进程或多线程任务，那么这些任务不可能是真实并
     * 行的，因为一个 CPU 一次只能执行一条指令，所以此时多进程或多线程是并发的，而不是并行的。
     * 真实的并行只可能出现在拥有多个 CPU 的系统中。
     *
     * 因为并发的最终效果可能是和并行是一样的，所以没有特别需要，不必刻意区分。
     *
     * 总结：并发和并行的区别在于多任务是否同时执行。
     * 1）并发：多任务不是同时执行的。
     * 2）并行：多任务是同时执行的。
     *
     *
     * （3）临界区（Critical Section）
     * 临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个
     * 线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。
     *
     * 在并行程序中，临界区资源是保护的对象。
     *
     *
     * （4）阻塞（Blocking）和非阻塞（Non-Blocking）
     * 阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其他所有
     * 需要这个资源的线程就必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是阻塞。
     * 此时，如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能
     * 工作。
     *
     * 非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行。所有的线程都会尝试不断前
     * 向执行。
     *
     * 总结：阻塞和非阻塞的区别在于线程执行时是否被其他线程影响。
     * 1）阻塞：线程执行时被其他线程影响。
     * 2）非阻塞：线程执行时不被其他线程影响。
     *
     *
     * （5）死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）
     * 死活、饥饿、活锁都属于多线程的活跃性问题。如果发生这几种情况，那么相关线程可能就不再活跃，
     * 也就是说可能很难再继续往下执行了。
     *
     * 按照严重情况：死锁 > 饥饿 > 活锁。
     *
     * 死锁产生的四个条件：
     * 1）互斥条件：该资源任意一个时刻只由一个线程占用。
     * 2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
     * 3）不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才
     *              释放资源。
     * 4）循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
     *
     * 饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。比如：它
     * 的线程优先级可能太低，而高优先级的线程不断抢占它所需要的资源，导致低优先级线程无法工作。
     * 另外一种可能是某一个线程一直占着关键资源不放，导致其他需要这个资源的线程无法正常执行。
     * 与死锁相比，饥饿还是有可能在未来一段时间内解决的。比如高优先级的线程已经完成任务，不再
     * 疯狂执行。
     *
     * 活锁是一种非常有趣的情况。即 两个线程互相 "礼让"，主动将资源释放给对方使用，就会出现
     * 资源不断地在两个线程中跳动，而没有一个线程可以同时拿到所有资源而正常执行。这种情况就是
     * 活锁。
     *
     */
    public static void main(String[] args) {

    }

}
