package com.siwuxie095.concurrent.chapter1st.example7th;

/**
 * @author Jiajing Li
 * @date 2020-08-20 23:03:27
 */
public class Main {

    /**
     * 有序性（Ordering）
     *
     * 有序性问题可能是三个问题中最难理解的。对于一个线程的执行代码而言，总是会习惯性地认为
     * 代码的执行是从先往后，依次执行的。这么理解不能说完全错误，因为就一个线程内而言，确实
     * 会表现成这样。但是在并发时，程序的执行可能就会出现乱序。给人直观的感觉就是：写在前面
     * 的代码，会在后面执行。这听起来可能有些不可思议。有序性问题的原因是因为程序在执行时，
     * 可能会进行指令重排，重排后的指令与原指令的顺序未必一致。
     *
     * 看一个简单的例子：OrderExample。假设线程 A 首先执行 writer() 方法，接着线程 B
     * 执行 reader() 方法，如果发生指令重排，那么线程 B 在代码第 10 行时，不一定能看到 a
     * 已经被赋值为 1 了。
     *
     * 即 指令重排后，writer() 方法中就先执行 flag = true 后执行 a = 1。这样线程 B 检查
     * 到 flag = true 时，a = 1 可能还没有执行。这就是指令重排导致的线程间语义不一致。
     *
     * 这确实是一个看起来很奇怪的问题，但是它确实可能存在。注意：这里是说可能存在。因为如果
     * 指令没有重排，这个问题就不存在了，但是指令是否发生重排、如何重排，是无法预测的。因此，
     * 对于这类问题，比较严谨的描述是：线程 A 的指令执行顺序在线程 B 看来是没有保证的。如果
     * 运气好的话，线程 B 也许真的可以看到和线程 A 一样的执行顺序。
     *
     * 不过这里需要强调一点，对于一个线程来说，它看到的指令执行顺序一定是一致的（否则应用根
     * 本无法正常工作）。也就是说，指令重排有一个基本前提：保证串行语义的一致性。指令重排不
     * 会使串行的语义逻辑发生问题。因此，在串行代码中，大可不必担心。
     *
     * 注意：指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。
     *
     * 那么，为什么要指令重排呢？一步一步执行的话，就不会有这些奇葩的问题了。之所以要这么做，
     * 完全是因为性能考虑。分析如下：
     *
     * 一条指令的执行是可以分为很多步骤的。简单地说，可以分为以下几步：
     * （1）取指 IF
     * （2）译码和取寄存器操作数 ID
     * （3）执行或者有效地址计算 EX
     * （4）存储器访问 MEM
     * （5）写回 WB
     *
     * 对于汇编指令来说，也不是一步就可以执行完毕的，在 CPU 中实际工作时，它还是需要分为多个
     * 步骤依次执行。当然，每个步骤所涉及的硬件也可能不同。比如，取指时会用到 PC 寄存器和存
     * 储器，译码时会用到指令寄存器组，执行时会使用 ALU，写回时需要寄存器组。
     *
     * 注意：ALU 是算术逻辑单元，它是 CPU 的执行单元，是 CPU 的核心组成部分，主要功能是进行
     * 二进制算术运算。
     *
     * 由于每个步骤都可能使用不同的硬件完成，因此，聪明的工程师们就发明了流水线技术来执行指令。
     *
     * 有了流水线这个神器，CPU 才能真正的高效执行，但是，流水线总是害怕被中断。流水线满载时，
     * 性能是很不错，但是一旦中断，所有的硬件设备都会进入一个停顿期，再次满载又需要几个周期，
     * 因此，性能损失会比较大。所以必须要想办法尽量不让流水线中断。
     *
     * 而指令重排，就是为了尽量少的中断流水线。当然，指令重排只是减少中断的一种技术，实际上，
     * 在 CPU 的设计中，还会使用更多的软硬件技术来防止中断，这里不过多探讨。
     *
     * 指令重排对于提高 CPU 处理性能是十分必要的。虽然确实带来了乱序的问题，但是这点牺牲是完全
     * 值得的。
     */
    public static void main(String[] args) {

    }

}
