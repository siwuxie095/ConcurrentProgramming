package com.siwuxie095.concurrent.chapter5th.example3rd;

/**
 * @author Jiajing Li
 * @date 2020-09-19 15:33:22
 */
public class Main {

    /**
     * 不变模式
     *
     * 在并行软件开发过程中，同步操作似乎是必不可少的。当多线程对同一个对象进行读写操作时，为了保证对象数据的一致性
     * 和正确性，有必要对对象进行同步。而同步操作对系统性能是有相当的损耗。为了能尽可能地去除这些同步操作，提高并行
     * 程序性能，可以使用一种不可变的对象，依靠对象的不变性，可以确保其在没有同步操作的多线程环境中依然始终保持内部
     * 状态的一致性和正确性。这就是不变模式。
     *
     * 不变模式天生就是多线程友好的，它的核心思想是，一个对象一旦被创建，则它的内部状态将永远不会发生改变。所以没有
     * 一个线程可以修改其内部状态和数据，同时其内部状态也绝不会自行发生改变。基于这些特性，对不变的多线程操作不需要
     * 进行同步控制。
     *
     * 同时还需要注意，不变模式和只读属性是有一定的区别的。不变模式是比只读属性具有更强的一致性和不变性。对只读属性
     * 的对象而言，对象本身不能被其他线程修改，但是对象的自身状态却可能自行修改。
     *
     * 比如，一个对象的存活时间（对象创建时间和当前时间的时间差）是只读的，因为任何一个第三方线程都不能修改这个属性，
     * 但是这是一个可变的属性，因为随着时间的推移，存活时间时刻都在发生变化。而不变模式则要求，无论出于什么原因，对
     * 象自创建后，其内部状态和数据要保持绝对的稳定。
     *
     * 因此，不变模式的主要使用场景需要满足以下 2 个条件：
     * （1）当对象创建后，其内部状态和数据不再发生任何变化。
     * （2）对象需要被共享，被多线程频繁访问。
     *
     * 在 Java 语言中，不变模式的实现很简单。为确保对象被创建后，不发生任何改变，并保证不变模式正常工作，只需要注意
     * 以下四点：
     *
     * （1）去除 setter 方法以及所有修改自身属性的方法；
     * （2）将所有属性设置为私有，并用 final 标记，确保其不可修改。
     * （3）确保没有子类可以重载修改它的行为。
     * （4）有一个可以创建完整对象的构造方法。
     *
     * 以 Product 为例，实现了一个不变的产品对象，它拥有序列号、名称和价格三个属性。
     *
     * 在不变模式的实现中，final 关键字起到了重要的作用。对属性的 final 定义确保所有数据只能在对象被构造时赋值一次。
     * 之后，就永远不再发生改变，而对 class 的 final 确保了类不会有子类。根据里氏代换原则（也称里氏替换原则），子类
     * 可以完全的替代父类。如果父类是不变的，那么子类也必须是不变的，但实际上并无法约束这一点，为了防止子类做出一些意
     * 外的行为，这里干脆把子类都禁用了。
     *
     * 在 JDK 中，不变模式的应用非常广泛。其中，最为典型的就是 java.lang.String 类。此外，所有的元数据类包装类（即
     * 基本数据类型对应的包装类），都是使用不变模式实现的。主要应用不变模式的类如下：
     *
     * （1）java.lang.String
     * （2）java.lang.Boolean
     * （3）java.lang.Byte
     * （4）java.lang.Character
     * （5）java.lang.Double
     * （6）java.lang.Float
     * （7）java.lang.Integer
     * （8）java.lang.Long
     * （9）java.lang.Short
     *
     * 由于基本数据类型和 String 类型在实际的软件开发中应用极其广泛，使用不变模式后，所有实例方法均不需要进行同步
     * 操作，保证了它们在多线程环境下的性能。
     *
     * 注意：不变模式通过回避问题而不是解决问题的态度来处理多线程并发访问控制。不变对象是不需要进行同步操作的。由于
     * 并发同步会对性能产生不良的影响，因此，在需求允许的情况下，不变模式可以提高系统的并发性能和并发量。
     */
    public static void main(String[] args) {

    }

}
