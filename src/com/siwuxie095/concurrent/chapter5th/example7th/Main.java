package com.siwuxie095.concurrent.chapter5th.example7th;

/**
 * @author Jiajing Li
 * @date 2020-09-25 07:53:48
 */
public class Main {

    /**
     * 并行流水线
     *
     * 并行算法虽然可以充分发挥多核 CPU 的性能，但不幸的是，并非所有的计算都可以改造成并行的形式。简单来说，执行过程
     * 中有数据相关性的运算都是无法完美并行化的。
     *
     * 假如现在有两个数，B 和 C。如果要计算 (B+C)*B/2，那么这个运算过程就是无法并行的。原因是，如果 B+C 没有执行完
     * 成，则永远算不出 (B+C)*B，这就是数据相关性。如果线程执行时，所需的数据存在这种依赖关系，那么就没有办法将它们
     * 完美的并行化。
     *
     * 那遇到这种情况时，有没有什么补救措施呢？答案是肯定的，那就是借鉴日常生产中的流水线思想。
     *
     * 比如，现在要生产一批小玩偶。小玩偶的制作分为四个步骤：
     * （1）第一要组装身体；
     * （2）第二要在身体上安装四肢和头部；
     * （3）第三要给组装完成的玩偶穿上一件漂亮的衣服；
     * （4）第四要加上包装，这样就可以出货了。
     *
     * 为了加快制作玩偶的进度，不可能叫四个人同时加工一个玩偶，因为这四个步骤有着严重的依赖关系。如果没有身体，就没有
     * 地方安装四肢，如果整体没有组装完成，就不能穿衣服，如果没有穿上衣服，就不能包装发货。因此，找四个人来做一个玩偶
     * 是毫无意义的。
     *
     * 但是如果现在要制作的不是一个玩偶，而是一万个玩偶，那情况就不同了。这时就可以找四个人：
     * （1）第一个人只负责组装身体，完成后交付第二个人；
     * （2）第二个人只负责安装头部和四肢，交付给第三个人；
     * （3）第三个人只负责穿衣服，并交付给第四个人；
     * （4）第四个人只负责包装发货。
     *
     * 这样所有人都可以一起工作，共同完成任务，而整个时间周期也能缩短到原来的 1/4 左右，这就是流水线的思想。一旦流水
     * 线满载，每次只需要一步（假设一个玩偶需要四步）就可以产生一个玩偶。
     *
     * 类似的思想可以借鉴到程序开发中。即使 (B+C)*B/2 无法并行，但是如果需要计算一大堆 B 和 C 的值，那依然可以将它
     * 流水化。首先将计算拆分成三个步骤：
     * （1）P1: A = B + C
     * （2）P2: D = A * B
     * （3）P3: D = D / 2
     *
     * 上述步骤中 P1、P2、P3 均在单独的线程中计算，并且每个线程只负责自己的工作。此时，P3 的计算结果就是最终需要的答
     * 案。P1 接收 B 和 C 的值，并求和，将结果输入给 P2。P2 求乘积后输入给 P3。P3 求商后得到最终值。一旦这条流水线
     * 建立，只需要一个计算步骤就可以得到 (B+C)*B/2 的结果。
     *
     * 以 Plus、Multiply、Divide、Msg、Stream 为例，来实现这个功能。
     *
     * 其中：
     * （1）Plus 即 P1，计算的是加法。
     * （2）Multiply 即 P2，计算的是乘法。
     * （3）Divide 即 P3，计算的是除法。
     * （4）Msg 是一个在线程间携带结果进行信息交换的载体。
     * （5）Stream 是主线程，进行流水线任务的提交。
     *
     * 在代码中：
     * （1）加法线程 P1 取得封装了两个操作数的 Msg，并进行求和，将结果传递给乘法线程 P2，当没有数据处理时，P1 进行等待。
     * （2）乘法线程 P2 计算相乘结果后，将中间结果传递给除法线程 P3。
     * （3）除法线程 P3 将结果除以 2 后输出最终的结果。
     * （4）最后提交任务的主线程，这里提交了 1000 * 1000 即 100 万个请求，让线程组进行计算。
     *
     * 流水线的计算在多核或者分布式场景中，可以有效将有依赖关系的操作分配在不同的线程中进行计算，尽可能利用多核优势。
     */
    public static void main(String[] args) {

    }

}
