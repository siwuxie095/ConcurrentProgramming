package com.siwuxie095.concurrent.chapter5th.example9th;

/**
 * @author Jiajing Li
 * @date 2020-09-26 09:27:17
 */
public class Main {

    /**
     * 并行排序
     *
     * 排序是一项非常常用的操作。应用程序在运行时，可能无时无刻不在进行排序操作。排序的算法有很多，这里不再一一介绍
     * 了。对于大部分排序算法来说，都是串行执行的。当排序元素很多时，若使用并行算法代替串行算法，显然可以更加有效地
     * 利用 CPU。但将串行算法改造成并行算法并非易事，甚至会极大地增加原有算法但复杂度。下面介绍几种相对简单，但是也
     * 足以让人脑洞大开的平行排序算法。
     *
     *
     *
     * 分离数据相关性：奇偶交换排序
     *
     * 在介绍奇偶交换排序前，先来看一下熟悉的冒泡排序。假设这里是要将数组进行从小到大的排序。冒泡排序的操作很类似水
     * 中的起泡上浮，在冒泡排序的过程中，如果数据较小，就会上浮，被交换到前面去，相反，对于大的数字，则会下沉，被交
     * 换到末尾（冒泡排序参见 BubbleSort 示例）。
     *
     * 冒泡排序在每次迭代的交换过程中，由于每次交换交换的两个元素存在数据冲突（即 存在大小之分），对于每个元素，它
     * 既可能与前面的元素交换，也可能与后面的元素交换。因此，很难直接改造成并行算法。
     *
     * 如果能够解开这种数据的相关性，就可以比较容易的使用并行算法来实现类似的排序。奇偶交换排序就是基于这种思想的。
     *
     * 对于奇偶交换排序来说，它将排序过程分为两个阶段，奇交换和偶交换。对于奇交换来说，它总是比较奇数索引以及其相邻
     * 的后续元素。而偶交换总是比较偶数索引和其相邻的后续元素。并且，奇交换和偶交换会成对出现，这样才能保证比较和交
     * 换涉及到数组中的每一个元素。
     *
     * 即
     *
     * 奇交换总是这样比较：索引 1 和索引 2 比较、索引 3 和索引 4 比较、索引 5 和索引 6 比较 ... 成对比较。
     * 偶交换总是这样比较：索引 0 和索引 1 比较、索引 2 和索引 3 比较、索引 4 和索引 5 比较 ... 成对比较。
     *
     * 由于将整个比较独立分割成奇阶段和偶阶段。这就使得在每一个阶段内，所有的比较和交换是没有数据相关性的。因此，每
     * 一次比较和交换都可以独立执行，也就可以并行化了。
     *
     * 以 SerialOddEvenSort 为例，是奇偶交换排序的串行实现。其中 exchangeFlag 用来记录当前迭代是否发生了数据交
     * 换，而 start 变量用来表示是奇交换还是偶交换。初始时，start 为 0，表示进行偶交换，每次迭代结束后，切换 start
     * 状态。如果上一次比较交换发生了数据交换，或者当前正在进行的是奇交换，循环就不会停止，直到程序不再发生交换，且
     * 当前进行是偶交换为止（表示奇偶交换已经成对出现）。
     *
     * SerialOddEvenSort 虽然是串行代码，但是已经可以很方便的改造成并行模式。以 ParallelOddEvenSort 为例，其
     * 中定义了奇偶排序的任务类。该任务的主要工作是进行数据比较和必要的交换。并行排序的主体是 parallelOddEvenSort()
     * 方法，它使用 CountDownLatch 记录线程数量，每一对元素的比较和交换使用单独的线程。在下一次迭代开始前，必须等
     * 待上一次迭代所有线程都完成。
     *
     *
     *
     * 改进的插入排序：希尔排序
     *
     * 插入排序也是一种很常用的排序算法。它的基本思想是：一个未排序的数组（当然也可以是链表）可以分为两个部分，前半
     * 部分是已经排序的，后半部分是未排序的。在进行排序时，只需要在未排序的部分中选择一个元素，将其插入到前面有序的
     * 数组中即可。最终，未排序的部分会越来越少，直到为 0，那么排序就完成了。初始时，可以假设已经排序的部分就是第一
     * 个元素。
     *
     * 以 InsertSort 为例，即为插入排序。首先提取准备要插入的元素（也就是未排序序列中的第一个元素）。接着，在已排
     * 序队列中找到这个元素的插入位置，并进行插入即可。
     *
     * 简单的插入排序很难并行化，因为这一次的数据插入依赖于上一次得到的有序序列，所以多个步骤之间无法并行，但是可以
     * 对插入排序进行扩展，也就是希尔排序。
     *
     * 希尔排序将整个数组根据间隔 h 分割为若干个子数组。子数组相互穿插在一起，每一次排序时，分别对每一个子数组进行
     * 排序。也就是说，每次排序，总是交换间隔为 h 的两个元素。
     *
     * 在每一组排序完成后，可以递减 h 的值，进行下轮更加精细的排序。直到 h 为 1，此时等价于一次插入排序。
     *
     * 希尔排序的一个主要优点是，即使一个较小的元素在数组的末尾，由于每次元素移动都以 h 为间隔进行，因此数组末尾的
     * 小元素可以在很少的交换次数下，就被置换到最接近元素最终位置的地方。
     *
     * 以 SerialShellSort 为例，是希尔排序的串行实现。先计算一个合适的 h 值，接着正式进行希尔排序。for 循环中进
     * 行间隔为 h 的插入排序，每次排序结束后，递减 h 的值，直到 h 为 1，退化为插入排序。
     *
     * 显然，希尔排序每次都针对不同的子数组进行排序，每个子数组之间是完全独立的。因此很容易改写成并行程序。
     *
     * 以 ParallelShellSort 为例，其中定义了 ShellSortTask 作为并行任务。一个 ShellSortTask 的作用是根据给
     * 定的起始位置和 h，对子数组进行排序，因此完全可以并行化。为控制线程数量，这里限制只有在 h 大于等于 4 时使用
     * 并行线程，否则退化为传统的插入排序。每次计算后，递减 h 的值。
     */
    public static void main(String[] args) {

    }

}
