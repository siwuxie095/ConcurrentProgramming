package com.siwuxie095.concurrent.chapter5th.example8th;

/**
 * @author Jiajing Li
 * @date 2020-09-25 22:04:15
 */
public class Main {

    /**
     * 并行搜索
     *
     * 搜索是几乎每一个软件都必不可少的功能。对于有序数据，通常可以采用二分查找法。对于无序数据，则只能挨个查找。
     * 下面要实现的就是有关并行的无序数组的搜索。
     *
     * 给定一个数组，要查找满足条件的元素。对于串行程序来说，只要遍历一下数组就可以得到结果。但如果要使用并行方式，
     * 则需要额外增加一些线程间的通信机制，使各个线程可以有效运行。
     *
     * 一种简单的策略就是将原始数据按照期望的线程数进行分割。如果计划使用两个线程进行搜索，那么就可以把一个数组或
     * 集合分割成两个。每个线程各自独立搜索，当其中有一个线程找到数据后，立即返回结果即可。
     *
     * 以 ParallelSearch 为例，其中有一个整形数组，需要查找数组内的元素。然后定义了线程池、线程数量以及存放结果
     * 的变量 result。在 result 中，会保存符合条件的元素在数组中的下标。默认为 -1，表示没有找到给定元素。
     *
     * 每个线程在进行每一次遍历时，都会通过 result 来判断是否已经有其他线程找到了需要的结果。如果已经找到，则立即
     * 返回，不再进行查找。如果没有找到，则进行下一步搜索。当前线程找到了需要的数据时，会通过 CAS 操作将结果保存到
     * result 中。如果设置失败，则表示其他线程已经先一步找到了结果。所以可以无视失败的情况，找到结果后，返回即可。
     *
     * 在并行搜索方法 parallelSearch() 中，会根据线程数量对数组进行划分，同时建立对应的任务提交给线程池处理。在
     * 该方法中使用了 JDK 内置的 Future 模式，每一个划分的任务提交给线程池后，都会返回一个 Future 对象，通过它
     * 可以获得最终的结果。这里由于线程之间通过 result 共享彼此的信息，所以只要当一个线程返回成功后，其他线程都会
     * 立即返回。这样就不会出现由于排在前面的任务长时间无法结束，而导致整个搜索结果无法立即获取的情况。
     */
    public static void main(String[] args) {

    }

}
