package com.siwuxie095.concurrent.chapter2nd.example14th;

/**
 * @author Jiajing Li
 * @date 2020-09-02 08:19:06
 */
public class Main {

    /**
     * 程序中的幽灵：无提示的错误案例
     *
     * 作为一名软件开发人员，修复程序 BUG 应该说是基本的日常工作之一。作为 Java 程序员，也许会经常被
     * 抛出一大堆的异常堆栈所困扰，因为这可能预示着又有工作要做了。但实际上，如果程序出错时可以看到异常
     * 堆栈，应该感到格外高兴才对，因为这意味着极有可能可以在两分钟内修复这个问题（当然，并不是所有的异
     * 常都是错误）。最可怕的情况是：系统没有任何异常表现，没有日志，也没有堆栈，但是却给出了一个错误的
     * 执行结果。这种隐蔽的错误，才真是让人抓狂。
     *
     * 这里给出一个系统运行错误，却没有任何提示的案例。如下所示，是求两个整数的平均值。乍看之下，没有什
     * 么问题。目测 v1 和 v2 的当前值，估计两者的平均值大约在 12 亿左右。但是执行代码却发现均值竟然是
     * 一个负数。显然，这是一个典型的溢出问题，v1 + v2 的结果就已经导致了 int 的溢出。
     *
     * 把这个问题单独拿出来研究，可能不会有特别的感触，但是一旦这个问题发生在一个复杂系统的内部。由于复
     * 杂的业务逻辑，很可能掩盖这个看起来微不足道的问题，再加上程序自始至终没有任何日志或异常，再加上运
     * 气不那么好的话，这类问题不熬上几个通宵，恐怕很难有眉目。
     *
     * 所以自然是希望在程序异常时，能够得到一个异常或者相关的日志。但是非常不幸的是，错误的使用并行，会
     * 非常容易产生这类问题。它们难觅踪影，就如同幽灵一般。
     */
    public static void main(String[] args) {
        int v1 = 1_073_741_827;
        int v2 = 1_431_655_768;
        System.out.println("v1 = " + v1);
        System.out.println("v2 = " + v2);
        int avg = (v1 + v2) / 2;
        System.out.println("avg = " + avg);
    }

}
