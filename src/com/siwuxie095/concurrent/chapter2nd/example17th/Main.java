package com.siwuxie095.concurrent.chapter2nd.example17th;

/**
 * @author Jiajing Li
 * @date 2020-09-02 23:03:38
 */
public class Main {

    /**
     * 程序中的幽灵：错误的加锁
     *
     * 在进行多线程同步时，加锁是保证线程安全的重要手段之一。但加锁也必须是合理的，在 example13th 中，
     * 已经给出了一个常见的错误加锁的案例，即 多个线程没有作用在同一个对象锁上面，也就是锁的不正确使用。
     * 这里将给出一个更加隐晦的错误加锁的案例。
     *
     * 以 BadLockOnInteger 为例，表示有一个计数器，这个计数器会被多个线程同时访问。为了确保数据的正
     * 确性，自然会需要对计数器加锁。为了保证计数器 i 的正确性，每次对 i 自增前，都先获得 i 的锁，以此
     * 保证 i 是线程安全的。从逻辑上看，这似乎没什么问题，但是一运行，却发现并不是预期的 20_000_000
     * 的结果（两个线程各累加 10_000_000），而是一个小了很多的数字。这说明这段程序一定没有真正的做到
     * 线程安全。但是把锁加在变量 i 上又有什么问题呢？似乎加锁的逻辑也是无懈可击的。
     *
     * 要解释这个问题，得从 Integer 说起。在 Java 中，Integer 属于不可变对象。也就是对象一旦被创建，
     * 就不可能修改。即 如果有一个 Integer 代表 1，那么它就永远表示 1，不可能修改 Integer 的值，使它
     * 变成 2。如果需要 2，只能新建一个 Integer，并让它表示 2。
     *
     * 通过 javap 命令对字节码进行反编译，得到汇编代码，可以看到 i++ 的时候，使用了 Integer.valueOf()
     * 方法新建了一个新的 Integer 对象，并将它赋值给变量 i。也就是说，i++ 在真实执行时变成了：
     *
     * i = Integer.valueOf(i.intValue() + 1);
     *
     * 通过查看源码，不难发现，Integer.valueOf() 实际上是一个工厂方法，它会倾向于返回一个代表指定数值
     * 的 Integer 实例。因此，i++ 的本质是创建一个新的 Integer 对象，并将它的引用赋值给 i。
     *
     * 如此一来，问题就明朗了。由于在两个线程之间，并不一定能够看到同一个 i 对象（因为 i 对象一直在变），
     * 所以，两个线程每次加锁可能都加在了不同的对象实例上，从而导致对临界区代码的控制出现了问题。
     *
     * 修正这个问题也很容易，将 synchronized(i) 改为 synchronized(instance) 即可。
     */
    public static void main(String[] args) {

    }

}
