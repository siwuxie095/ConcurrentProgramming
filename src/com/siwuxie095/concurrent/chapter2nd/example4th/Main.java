package com.siwuxie095.concurrent.chapter2nd.example4th;

/**
 * @author Jiajing Li
 * @date 2020-08-25 08:03:42
 */
public class Main {

    /**
     * 线程的基本操作：终止线程
     *
     * 一般来说，线程在执行完毕后就会结束，无须手工关闭。但是凡事也都有例外。一些服务端的后台线程可能会常驻系统，
     * 它们通常不会正常终结。比如，它们的执行体本身就是一个大大的无穷循环，用于提供某些服务。
     *
     * 那如何正常的关闭一个线程呢？通过查阅源码，不难发现，Thread 提供了一个 stop() 方法。如果你使用 stop()
     * 方法，就可以立即将一个线程终止，非常方便。但实际上，截止到目前（2020/08/25），stop() 方法是一个被标注
     * 为废弃的方法（参照版本：Java 8）。也就是说，在将来，JDK 可能就会移除该方法。
     *
     * 为什么 stop() 方法被废弃而不推荐使用呢？原因是 stop() 方法太过于暴力，强行把执行到一半的线程终止，可能
     * 会引起一些数据不一致的问题。
     *
     * 为了更好的理解，先介绍一个有关数据不一致的问题。假设在数据库中维护着一张用户表，里面记录了用户的 id 和
     * name。
     *
     * 记录1：id=1，name=小明
     * 记录2：id=2，name=小王
     *
     * 如果用一个 User 对象去保存这些记录，且总是希望这个对象要么保存记录1，要么保存记录2。那么当这个对象一半
     * 保存着记录1，另外一半保存着记录2时，就出现了数据不一致，说白了就是系统有错误了。比如：id=1，name=小王。
     * 这种情况是相当危险的，如果把一个不一致的数据直接写入了数据库，那么就会造成数据永久地被破坏和丢失，后果
     * 不堪设想。
     *
     * 可能有人会问，这怎么可能呢？跑得好好的系统，怎么会出现这种问题呢？在单线程环境中，确实不会，但在并行程序
     * 中，如果考虑不周，就有可能出现类似的情况。不经思考地使用 stop() 就有可能导致这种问题。
     *
     * Thread.stop() 方法在结束线程时，会直接终止线程，并且会立即释放这个线程所持有的锁。而这些锁恰恰是用来维
     * 持对象一致性的。如果此时写线程数据正写到一半并强行终止，那么这个对象就会被写坏，同时，由于锁已经被释放，
     * 另一个等待该锁的读线程就顺理成章的读到了这个不一致的对象，悲剧也就此发生。
     *
     * 这个过程可以用 StopThreadUnsafe 类中的代码模拟，读线程 ReadObjectThread 在读到对象的 id 和 name
     * 不一致时，会输出这些对象。而写线程 WriteObjectThread 总是会写入两个相同的值。注意，写线程启动 150 ms
     * 后会通过 stop() 方法强行终止写线程。
     *
     * 此时很容易得到如下输出，id 和 name 不一致：
     * User{id=1598365612, name='1598365611'}
     * User{id=1598365613, name='1598365612'}
     *
     * 如果在线上环境跑出了以上结果，那么加班加点估计是免不了，因为这类问题一旦出现，就很难排查，因为它们没有任何
     * 错误信息，也没有线程堆栈。这种情况一旦混杂在动则十几万行的程序代码中时，发现它们就全凭经验、时间还有一点点
     * 运气了。因此，除非你很清楚你在做什么，否则不要随便使用 stop() 方法来停止一个线程。
     *
     * 那如果要停止一个一个线程时，应该怎么做呢？其实方法很简单，自己自行决定线程何时退出就可以了。以 StopThreadSafe
     * 为例，在 WriteObjectThread 中增加一个 stopMe() 方法，并且定义了一个标记变量 stopMe，用于指示线程是否
     * 需要退出。当 stopMe() 方法被调用，stopMe 被设置为 true。此时，写线程检测到这个改动，线程就自然退出了。
     * 使用这种方式退出线程，不会使对象的状态出现错误，因为已经没有机会写坏对象了，它总会选择在一个合适的时间终止
     * 线程。
     */
    public static void main(String[] args) throws InterruptedException {

    }

}
