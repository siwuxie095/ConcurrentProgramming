package com.siwuxie095.concurrent.chapter3rd.example12th;

/**
 * @author Jiajing Li
 * @date 2020-09-06 22:24:24
 */
public class Main {

    /**
     * 超负载了怎么办：拒绝策略
     *
     * ThreadPoolExecutor 的最后一个参数指定了拒绝策略。也就是当任务数量超过系统实际承载能力时，该如何处理呢？
     * 这时就要用到拒绝策略了。拒绝策略可以说是系统超负荷运行时的补救措施，通常由于压力太大引起的，也就是线程池中
     * 的线程已经用完了，无法继续为新任务服务，同时，等待队列中也已经排满了，再也塞不下新任务了。这时就需要有一套
     * 机制，来合理的处理这个问题。
     *
     * JDK 内置了四种拒绝策略，如下：
     * （1）AbortPolicy 策略：该策略会直接抛出异常，阻止系统正常工作。（默认策略）
     * （2）CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务，显然这样做
     * 不会真的丢弃任务，但是任务提交线程的性能极有可能会急剧下降（比如在主线程中，启动一个线程池，如果执行了该拒绝
     * 策略，那么该任务就会在主线程中运行，且会阻塞主线程）。
     * （3）DiscardOldestPolicy 策略：该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前
     * 任务。
     * （4）DiscardPolicy 策略：该策略默默的丢弃当前无法处理的任务，不予任何处理。如果允许任务丢失，这可能是最好
     * 的一种方案了。
     *
     * 以上内置的策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际应用需要，完全可以自己实现
     * RejectedExecutionHandler 接口。RejectedExecutionHandler 中的接口定义如下：
     *
     * void rejectedExecution(Runnable r, ThreadPoolExecutor executor)
     *
     * 其中 r 为请求执行的任务，executor 为当前的线程池。
     *
     * 以 RejectThreadPoolDemo 为例，其中定义了一个线程池，该线程池有 5 个常驻线程，并且最大线程数量也是 5 个。
     * 这和固定大小的线程池是一样的。但是它却拥有一个只有 10 个容量的等待队列。因为使用无界队列很可能并不是最佳解决
     * 方案，如果任务量极大，很有可能会把内存撑爆。给出一个合理的队列大小，也是合乎常理的选择。同时，这里自定义了拒
     * 绝策略，这里不抛出异常，因为万一在任务提交端没有进行异常处理，则有可能使得整个系统都崩溃，这极有可能不是所期望
     * 的结果。但作为必要的信息记录，这里将任务丢弃的信息进行打印，当然，这只比内置的 DiscardPolicy 策略高级那么
     * 一点点。
     *
     * 在本例中，MyTask 执行需要花费 100 毫秒，所以，必然会导致大量的任务被直接丢弃。运行代码，可以看到，在执行几
     * 个任务后，拒绝策略就开始生效了。在实际应用中，可以将更详细的信息记录到日志中，来分析系统的负载和任务丢失情况。
     */
    public static void main(String[] args) {

    }

}
