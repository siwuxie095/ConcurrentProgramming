package com.siwuxie095.concurrent.chapter3rd.example17th;

/**
 * @author Jiajing Li
 * @date 2020-09-08 07:23:26
 */
public class Main {

    /**
     * 分而治之：Fork/Join 框架
     *
     * "分而治之" 一直是一个非常有效地处理大量数据的办法。著名的 MapReduce 也是采取了分而治之的思想。简单来说，
     * 就是如果要处理 1000 个数据，但是现在并不具备处理 1000 个数据的能力，那么可以只处理其中 10 个，然后分阶
     * 段处理 100 次，将 100 次的结果进行合成，那就是最终想要的对原始 1000 个数据的处理结果。
     *
     * Fork 一词的原始含义是吃饭用的叉子，也有分叉的意思。在 Linux 平台中，函数 fork() 用来创建子进程，使得
     * 系统进程可以多一个执行分支。在 Java 中也沿用了类似的命名方式。而 Join 的含义也类似于线程里的 join()
     * 方法，表示等待的意思。
     *
     * 具体到 Fork/Join 框架，也就是使用 fork() 后系统多了一个执行分支（线程），所以需要 join() 等待这个执行
     * 分支执行完毕，才有可能得到最终的结果。
     *
     * 在实际使用中，如果毫无顾忌地使用 fork() 开启线程进行处理，那么很有可能导致系统开启过多的线程而严重影响性能。
     * 所以，JDK 中给出了一个 ForkJoinPool 线程池，对于 fork() 方法，并不着急开启线程，而是提交给 ForkJoinPool
     * 线程池进行处理，以节省系统资源。
     *
     * 由于线程池的优化，提交的任务和线程数量并不是一对一的关系。在绝大多数情况下，一个物理线程实际上是需要处理多个
     * 逻辑任务的。因此，每个线程必然拥有一个任务队列。因此，在实际执行过程中，可能会遇到这么一种情况：线程 A 已经
     * 把自己的任务都执行完毕了，而线程 B 还有一堆任务等着处理，此时，线程 A 就会 "帮助" 线程 B，从线程 B 的任务
     * 队列中拿一个任务过来处理，尽可能地达到平衡（即 互帮互助）。值得注意的是，当线程试图帮助别人时，总是从任务队列
     * 的底部（尾部）开始拿任务，而线程试图执行自己的任务时，则是从相反的顶部（头部）开始拿任务。这种行为十分有利于
     * 避免数据竞争。
     *
     * ForkJoinPool 有一个重要的方法，如下：
     *
     * public <T> ForkJoinTask<T> submit(ForkJoinTask<T> task)
     *
     * 可以通过这个方法 ForkJoinPool 向线程池提交一个 ForkJoinTask 任务。所谓 ForkJoinTask 任务就是支持 fork()
     * 分解以及 join() 等待的任务。ForkJoinTask 有两个重要的子类，RecursiveAction 和 RecursiveTask，它们分别
     * 表示没有返回值的任务和可以携带返回值的任务。
     *
     * 以 CountTask 为例，使用 Fork/Join 框架来计算数列求和。
     *
     * 由于计算数列的和必然是需要返回值的，因此，选择 RecursiveTask 作为任务模型。先建立 ForkJoinPool 线程池，然后
     * 构造一个计算 1 到 200_000 求和的任务，并将该任务提交给线程池。线程池会返回一个携带结果的任务，通过 get() 方法
     * 可以得到一个最终结果（其实是 Future 的 get() 方法）。如果在执行 get() 方法时，任务没有结束，那么主线程就会在
     * get() 方法处等待。
     *
     * 对于 CountTask，它是继承自 RecursiveTask，可以携带返回值，这里的返回值类型设置为 Long。其中定义了任务分解的
     * 规模 THRESHOLD，如果需要求和的总数大于 THRESHOLD，那么任务就需要再次分解，否则就可以直接执行。如果任务可以直
     * 接执行，那么直接进行求和，返回结果。否则就对任务再次分解，每次分解时，简单将原有任务划分成 100 个等规模的小任务，
     * 并使用 fork() 提交子任务。之后，使用 join() 等待所有的子任务结束，并将结果再次求和。
     *
     * 在使用 Fork/Join 时需要注意，如果任务划分的层次很深，一直得不到返回，那么可能出现两种情况：
     * （1）系统内线程数量越积越多，导致性能严重下降。
     * （2）方法的调用层次变得很深，最终导致栈溢出。
     *
     * 不同版本的 JDK 内部实现机制可能有差异，从而导致其表现不同。比如，当加深调用层次时，JDK 8 上会报如下错误：
     *
     * java.util.concurrent.ExecutionException: java.lang.StackOverflowError
     * 或者
     * java.util.concurrent.ExecutionException: java.lang.NoClassDefFoundError
     *
     * （PS：JDK 版本不同，报错也可能不同）
     *
     * 此外，ForkJoinPool 线程池使用一个无锁的栈来管理空闲线程。如果一个工作线程暂时取不到可用的任务，则可能会被挂起，
     * 挂起的线程将会被压入由线程池维护的栈中。待将来有任务可用时，再从栈中唤醒这些线程。
     */
    public static void main(String[] args) {

    }

}
