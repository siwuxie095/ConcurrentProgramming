package com.siwuxie095.concurrent.chapter3rd.example16th;

/**
 * @author Jiajing Li
 * @date 2020-09-07 08:36:40
 */
public class Main {

    /**
     * 堆栈去哪里了：在线程池中寻找堆栈
     *
     * 在编程中，开发者最害怕的就是一些幽灵般的错误，既没有错误日志，又没有异常堆栈，如同一个黑洞一般，很难去排查
     * 这类问题。而多线程恰恰非常容易引起这类错误。如果使用了线程池，那么这种幽灵错误可能会变得更加常见。
     *
     * 以 DivTask 为例，这个任务是用来计算两个数的商，从 for 循环来看，应该会得到 5 个输出，分别是 100 除以给定
     * i 后的商，但是实际运行却会发现，只有 4 个输出。也就是说程序漏算了一组数据。更不幸的是，程序没有任何日志，也
     * 没有任何错误提示，就好像一切都正常一样。在本例中，不难发现，作为除数 i 取到了 0，这个缺失的值正是由于除以 0
     * 导致的。然而在稍微复杂的业务场景中，这种错误却可以让人好几天都萎靡不振。
     *
     * 因此，使用线程池虽然是件好事，但是还是得处处留意这些坑，线程池很有可能会吃掉程序抛出的异常，导致开发者对程序
     * 一无所知。异常堆栈对于开发者的重要性就好像指南针对于茫茫大海上的船只。没有指南针，船只只能更艰难地寻找方向。
     * 没有异常堆栈，排查问题时，也只能像大海捞针那样，慢慢琢磨了。
     *
     * 下面将讨论向线程池讨回异常堆栈的方法。
     *
     * 一种最简单的方法，就是放弃 submit()，改用 execute()。另一种方法则是使用 Future 去接收 submit() 的返回
     * 值，并调用 get() 方法获取结果（如果任务没有执行完，会在此方法处等待，直到获取到结果）。
     *
     * 上述两种方法都只能得到部分异常堆栈的信息，注意，只是部分，这是因为从这两个异常堆栈中，只能知道异常是在哪里抛出
     * 的，但是还希望知道另外一个重要信息，那就是这个任务到底是在哪里提交的。而任务的具体提交位置已经被线程池完全淹没
     * 了。顺着堆栈，最多只能找到线程池中的调度流程（异常抛出的位置附近），而这几乎是没有价值的。
     *
     * 所以，还是有必要自己动手，丰衣足食，来把异常堆栈信息彻底挖出来。以 TraceThreadPoolExecutor 为例，它继续自
     * ThreadPoolExecutor，这里让它在调度任务之前，先保存一下提交任务线程（在这里是主线程）的堆栈信息。其中有一个
     * wrap() 方法，它的第二个参数为一个异常，里面保存着提交任务线程的堆栈信息。该方法将传入的 Runnable 任务进行
     * 一次包装，使之能够处理异常信息。当任务发生异常时，第二个参数表示的异常会被打印。
     *
     * 运行代码，就会发现，不仅可以得到异常发生的 Runnable 实现内的信息，还知道了这个任务是在哪里提交的。如此丰富的
     * 信息，可以帮助开发者瞬间定位问题。
     */
    public static void main(String[] args) {

    }

}
