package com.siwuxie095.concurrent.chapter3rd.example2nd;

/**
 * @author Jiajing Li
 * @date 2020-09-03 07:50:54
 */
public class Main {

    /**
     * synchronized 的功能扩展：重入锁
     *
     * 重入锁可以完全替代 synchronized 关键字。在 JDK 5.0 的早期版本中，重入锁的性能远远好于 synchronized，
     * 但从 JDK 6.0 开始，JDK 在 synchronized 上做了大量的优化，使得两者的性能差距并不大。
     *
     * PS：其实 synchronized 也是重入锁，只不过一般的叫法是直接说 synchronized，而说到重入锁时，一般都是指
     * ReentrantLock，但是具体来说，还是要结合上下文的语境去理解。（重入锁，也称 可重入锁。）
     *
     * 重入锁使用 java.util.concurrent.locks.ReentrantLock 类来实现。以 ReenterLock 为例进行说明，本例
     * 使用重入锁保护临界区资源 i，确保多线程对 i 操作的安全性。从这段代码可以看到，与 synchronized 相比，重
     * 入锁有着显式的操作过程。开发者必须手动指定何时加锁，何时释放锁。也正因为这样，重入锁对逻辑控制的灵活性要
     * 远远好于 synchronized。但值得注意的是，在退出临界区时，必须记得释放锁，否则其他线程就没有机会再访问临界
     * 区了。
     *
     * 有人可能会对重入锁的名字感到奇怪。锁就叫锁呗，为什么要加上 "重入" 两个字呢？从类的命名上看，ReentrantLock
     * 即 Re-Entrant-Lock，翻译成重入锁也是非常贴切的。之所以这么叫，那是因为这种锁是可以反复进入的。当然反复
     * 进入仅仅局限在同一个线程。所以使用重入锁的代码可以写成下面这种形式：
     *
     * lock.lock();
     * lock.lock();
     * try {
     *     i++;
     * } finally {
     *     lock.unlock();
     *     lock.unlock();
     * }
     *
     * 在这种情况下，一个线程连续两次获得同一把锁，这是允许的！如果不允许这么操作，那么同一个线程在第二次获得锁
     * 时，将会和自己产生死锁（即 自己已经获得了锁，自己不释放的情况下，自己无法再获得锁）。程序就会卡死在第二次
     * 申请锁的过程中。值得注意的是，如果同一个线程多次获得锁，那么释放锁的时候，也必须释放相同次数。如果释放的
     * 次数多，那么会得到一个 java.lang.IllegalMonitorStateException 异常，反之，如果释放锁的次数少了，那
     * 么相当于线程还持有这个锁，因此，其他线程也无法进入临界区。
     *
     * 除了使用上的灵活性，重入锁还提供了一些高级功能。比如，重入锁可以提供中断处理的能力。
     *
     *
     * 中断响应
     *
     * 对于 synchronized 来说，如果一个线程在等待锁，那么结果只有两种情况，要么它获得这把锁继续执行，要么它就
     * 保持等待。而使用重入锁，则提供了另外一种可能，那就是线程可以被中断。也就是在等待锁的过程中，程序可以根据
     * 需要取消对锁的请求。有些时候，这么做是非常有必要的。比如，你和朋友约好一起打球，如果等了半小时朋友还没到，
     * 突然接到一个电话，说由于突发情况，不能如约了，那么你就要扫兴的打道回府了，不可能再等下去。而中断即是提供
     * 了一套类似的机制。如果一个线程正在等待锁，那么它依然可以收到一个通知，被告知无须再等待，可以停止工作了。
     * 这种情况对于处理死锁是有帮助的。
     *
     * 以 IntLock 为例，这段代码产生了死锁，但得益于锁中断，所以可以很轻易地解决这个死锁。线程 t1 和 t2 启动
     * 后，t1 先占用 lock1，再请求 lock2；t2 先占用 lock2，再请求 lock1。因此，很容易形成 t1 和 t2 之间的
     * 相互等待。在这里，对锁的请求，统一使用 lockInterruptibly() 方法。这是一个可以对中断进行响应的锁申请动
     * 作，即 在等待锁的过程中，可以响应中断。
     *
     * 在主线程 main 处于休眠时，这两个线程处于死锁的状态。然后由于 t2 线程被中断，所以 t2 会放弃对 lock1 的
     * 申请，继续往下执行 finally 块释放已获得的 lock2。lock2 释放后，t1 线程就可以顺利得到 lock2 而继续往
     * 下执行。
     *
     * 12:线程退出
     * 11:线程退出
     * java.lang.InterruptedException
     * 	at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:898)
     * 	at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:1222)
     * 	at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335)
     * 	at com.siwuxie095.concurrent.chapter3rd.example2nd.IntLock.run(IntLock.java:32)
     * 	at java.lang.Thread.run(Thread.java:748)
     *
     * 	运行代码，可以看到中断后两个线程双双退出。但真正完成工作的只有 t1。而 t2 线程则放弃其任务直接退出，并
     * 	释放资源。
     *
     *
     * 锁申请等待限时
     *
     * 除了等待外部通知之外，要避免死锁还有另外一种方法，那就是限时等待。依然以约朋友打球为例，如果朋友迟迟不来，
     * 又无法联系到他。那么在等待 1～2 小时后，大概大部分人都会扫兴离去。其实对线程也是这样。通常来说是无法判断
     * 为什么一个线程迟迟拿不到锁。也许是因为死锁了，也许是因为产生了饥饿。但如果给定一个等待时间，让线程自动放
     * 弃，那么对系统来说是有意义的，可以使用 tryLock() 方法进行一次限时的等待。
     *
     * 以 TimeLock 为例，展示了限时等待锁的使用。这里 tryLock() 方法接收两个参数，一个表示等待时长，另外一个
     * 表示计时单位。这里的单位设置为秒，时长为 5，表示线程在这个锁请求中，最多等待 5 秒，如果超过 5 秒还没有
     * 得到锁，就会返回 false。如果成功获得锁，则返回 true。在本例中，由于占用锁的线程会持有锁达 6 秒，故另一
     * 个线程无法在 5 秒的等待时间内获得锁，因此，请求锁会失败。
     *
     * ReentrantLock.tryLock() 方法也可以不带参数直接运行。在这种情况下，当前线程会尝试获得锁，如果锁并未被
     * 其他线程占用，则申请锁会成功，并立即返回 true。如果锁被其他线程占用，则当前线程不会进行等待，而是立即返
     * 回 false。这种模式不会引起线程等待，因此也不会产生死锁。
     *
     * 以 TryLock 为例，采用了非常容易死锁的加锁顺序。也就是先让 t1 获得 lock1，再让 t2 获得 lock2，接着做
     * 反向请求，让 t1 申请 lock2，t2 申请 lock1。在一般情况下，这会导致 t1 和 t2 相互等待，从而引起死锁。
     * 但是使用 tryLock() 后，这种情况就大大改善了。由于线程不会傻傻地等待，而是不停地尝试，因此，只要执行足够
     * 长的时间，线程总是会得到所有需要的资源，从而正常执行（这里以线程同时获得 lock1 和 lock2 两把锁，作为其
     * 可以正常执行的条件）。在同时获得 lock1 和 lock2 后，线程就打印出标志任务完成的信息 "My Job Done"。
     *
     * 运行代码，等待一会儿（由于线程中包含休眠 500 毫秒的代码）。最终还是可以欣喜的看到程序执行完毕，并产生如下
     * 输出，表示两个线程双双正常执行。
     *
     * 12:My Job Done
     * 11:My Job Done
     *
     *
     * 公平锁
     *
     * 在大多数情况下，锁的申请都是非公平的。也就是说，线程 1 首先请求了锁 A，接着线程 2 也请求了锁 A。那么当
     * 锁 A 可用时，是线程 1 可以获得锁还是线程 2 可以获得锁呢？这是不一定的。系统只会从这个锁的等待队列中随机
     * 挑选一个。因此不能保证其公平性。这就好比买票不排队，大家都乱哄哄的围在售票窗口前，售票员忙的焦头烂额，也
     * 顾不及谁先谁后，随便找个人出票就完事了。而公平的锁，则不是这样，它会按照时间的先后顺序，保证先到者先得，
     * 后到者后得。公平锁的一大特点是：它不会产生饥饿现象。只要你排队，最终还是可以等到资源的。如果使用 synchronized
     * 关键字进行锁控制，那么产生的锁就是非公平的。而重入锁则允许对其公平性进行设置。它有如下一个构造方法：
     *
     * public ReentrantLock(boolean fair)
     *
     * 当参数 fair 为 true 时，表示锁是公平的。公平锁看起来很优美，但是要实现公平锁必然要求系统维护一个有序队列，
     * 因此公平锁的实现成本比较高，性能相对也非常低下，因此，默认情况下，锁是非公平的。如果没有特别的需求，也不需
     * 要使用公平锁。公平锁和非公平锁在线程调度表现上也非常不一样。
     *
     * 以 FairLock 为例，可以很好的突出公平锁的特点。两个线程 t1 和 t2 分别请求公平锁，并且在得到锁后进行控制台
     * 输出，表示自己得到了锁。在公平锁的情况下，得到的输出通常如下：
     *
     * 12 get lock
     * 11 get lock
     * 12 get lock
     * 11 get lock
     * 12 get lock
     * 11 get lock
     * 12 get lock
     * 11 get lock
     *
     * 不难看出，两个线程基本是交替获得锁的，几乎不会发生同一个线程连续多次获得锁的可能，从而公平性也得到了保证，
     * 如果不使用公平锁，那么情况会完全不一样。以 UnfairLock 为例，可以看到，根据系统的调度，一个线程会倾向于
     * 再次获得已经持有的锁，这种分配方式是高效的，但是无公平性可言。
     *
     * 12 get lock
     * 12 get lock
     * 12 get lock
     * 12 get lock
     * 12 get lock
     * 12 get lock
     * 12 get lock
     * 12 get lock
     * 11 get lock
     * 11 get lock
     *
     *
     *
     * 对上面 ReentrantLock 对几个重要方法整理如下：
     * （1）lock()：获得锁，如果锁已经被占用，则等待。
     * （2）lockInterruptibly()：获得锁，但优先响应中断。
     * （3）tryLock()：尝试获得锁，如果成功，返回 true，如果失败，返回 false。该方法不等待，立即返回。
     * （4）tryLock(long time, TimeUnit unit)：在给定时间内尝试获得锁。
     * （5）unlock()：释放锁。
     *
     * 就重入锁的实现来看，它主要集中在 Java 层面。在重入锁的实现中，主要包含三个要素：
     * （1）原子状态：原子状态使用 CAS 操作来存储当前锁的状态，判断锁是否已经被别的线程持有。
     * （2）等待队列：所有没有请求到锁的线程，会进入等待队列进行等待。待有线程释放锁后，系统就能从等待队列中唤醒一个线程，继续工作。
     * （3）阻塞原语：park() 和 unpark()，用来挂起和恢复线程。没有得到锁的线程将会被挂起。
     */
    public static void main(String[] args) {

    }

}
